
(*************************)
(*   Auteurs             *)
(* Josselin BOUCHER G1.1 *)
(* Eliaz ANDRE LE POGAMP*)
(*************************)

module TriEx1 (* EXERCICE 1 *)
  use int.Int
  use ref.Ref
  use ref.Refint
  use array.Array
  use array.IntArraySorted (* sorted et sorted_sub *)
  use array.ArraySwap      (* swap *)
  use array.ArrayPermut    (* permut_all *)
  use array.ArrayEq

(* Prédicats et sous-programme utiles (et vus au cours 3)

  predicate sorted (a : array int)

  predicate sorted_sub (a : array int) (i j : int)

  predicate permut_all (a1 a2: array 'a)

  val swap (a: array int) (i: int) (j: int) =
  requires { 0 <= i < length a /\ 0 <= j < length a }
  ensures { exchange (old a) a i j }
*)

(* Question 1 *)
let minimum (t:array int) (m n:int) : int 
  requires { 0 < length t }
  requires { 0 <= m < n <= length t }
  ensures { m <= result < n }
  ensures { forall x:int. m <= x < n -> t[result] <= t[x] }
= 
  let ref min = m in
  for i = m+1 to n-1 do
    invariant { m <= min < n }
    invariant { forall x:int. m <= x < i -> t[min] <= t[x] }
    if t[i] < t[min] then
      min := i
    else
      ()
  done;
  min





(* !---- utiliser les tests du module TriEx1Tests 
         pour tester le code écrit --------------! *)

(* Question 2 *)
let tri_selection (t: array int) : unit
  requires { 0 < length t }
  ensures { forall i j:int. 0 <= i < j < length t -> t[i] <= t[j] }
= 
  writes { t }
  let n = length t in
  for i = 0 to n - 2 do
    invariant { 0 <= i <= n  /\ permut_all t (old t) }
    invariant { forall j k:int. 0 <= j < i -> i <= k < n -> t[j] <= t[k] }
    let j = minimum t i n in
    let tmp = t[i] in
    t[i] <- t[j];
    t[j] <- tmp;
  done;
  
 
end
(* !---- utiliser les tests du module TriEx1Tests 
         pour tester le code écrit --------------! *)



module TriEx1Tests
  use int.Int
  use array.Array
  use array.ArrayEq
  use TriEx1

(* Question 2 : tests *)

(* Test du code des programmes    *)

(*
Ce test est à exécuter avec la commande suivante :

why3 execute tp-tris.mlw --use=TriEx1Tests 'test_minimum ()'

Execution of TriEx1.test_minimum ():
     type: int
   result: 8
C'est bien le résultat attendu.
   
Attention à ne pas mettre d'assertion dans un tel test
(car execute ne les vérifierait pas) !   
*)

  let test_minimum () :  int = 
  let t = make 9 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6; t[8] <- 10;
  minimum t 0 (length t)

  let test_minimum2() :  int = 
  let t = make 19 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  t[8] <- 1 ; t[9] <- 0 ; t[10] <- 5; t[11] <- 10;
  t[12] <- 3; t[13] <- 99; t[14] <- 2 ; t[15] <- 6;
  t[16] <- 8 ; t[17] <- 1; t[18] <- 9;
  minimum t 0 (length t)

  let test_minimum3 () :  int = 
  let t = make 9 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  minimum t 0 (length t)

(* Question 2 : test *)
(* Ce test est à exécuter depuis un terminal,
   avec la commande suivante :
   
why3 execute tp-tris.mlw --use=TriEx1Tests 'test_minimum ()'
  
*)

  let test_triSelection() : array int = 
  let t = make 9 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  tri_selection t ; 
  t

  let test_triSelection2() : array int = 
  let t = make 19 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  t[8] <- 1 ; t[9] <- 0 ; t[10] <- 5; t[11] <- 10;
  t[12] <- 3; t[13] <- 99; t[14] <- 2 ; t[15] <- 6;
  t[16] <- 8 ; t[17] <- 1; t[18] <- 9;
  tri_selection t ; 
  t

end

module TriEx2 (* EXERCICE 2 *)
  use int.Int
  use ref.Ref
  use ref.Refint
  use array.Array
  use array.IntArraySorted
  use array.ArrayPermut
  use array.ArrayEq

(* Question 1 *)
(* Compléter la spécification et les invariants du programme suivant *)
(* Cette version est plus simple que celle proposée sur wikipedia.   *)

  let tri_insertion_v0 (t: array int) : unit
    requires { 0 < length t }
    ensures { forall i j: int. 0 <= i < j < length t -> t[i] <= t[j] }
  = 
    let n = length t in
    for i = 1 to n - 1 do
      invariant { 1 <= i <= n }
      invariant { forall k: int. 0 <= k < i - 1 -> t[k] <= t[k+1] }
      let courant = t[i] in
      let ref j = i in
      while (j > 0 && t[j - 1] > courant) do
        variant { j }
        invariant { 0 <= j <= i }
        invariant { forall k: int. 0 <= k < j - 1 -> t[k] <= t[k+1] }
        invariant { forall k: int. j <= k < i -> t[k] >= courant /\ permut_all t (old t)}
        t[j] <- t[j - 1];
        decr j
      done;
      t[j] <- courant
    done
 


(* Question 2 *)
(* En s'inspirant de tri_insertion_v0, spécifier, programmer et prouver 
   la version plus optimisée de wikipedia *)
  let tri_insertion (t: array int) : unit 
    requires { 0 < length t }
    ensures { forall i j: int. 0 <= i < j < length t -> t[i] <= t[j] }
  =     
  let n = length t in
  for i = 1 to n - 1 do
    invariant { 1 <= i <= n }
    invariant { forall k: int. 0 <= k < i - 1 -> t[k] <= t[k+1] }
    let x = t[i] in
    let ref j = i in
    while (j > 0 && t[j - 1] > x) do
        variant { j }
        invariant { 0 <= j <= i }
        invariant { forall k: int. 0 <= k < j - 1 -> t[k] <= t[k+1] }
        invariant { forall k: int. j <= k < i -> t[k] >= x }
        t[j]<-t[i]
    done
 done 
             
end 

module TriEx2Tests
  use int.Int
  use array.Array
  use array.ArrayEq
  use TriEx1
  use TriEx2

  let test_triInsertion() : array int = 
  let t = make 9 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  tri_insertion_v0 t ; 
  t

  let test_triInsertion2() : array int = 
  let t = make 19 1 in 
  t[0] <- 9 ; t[1] <- 7 ; t[2] <- 8 ; t[3] <- 5;
  t[4] <- 2 ; t[5] <- 4 ; t[6] <- 3 ; t[7] <- 6;
  t[8] <- 1 ; t[9] <- 0 ; t[10] <- 5; t[11] <- 10;
  t[12] <- 3; t[13] <- 99; t[14] <- 2 ; t[15] <- 6;
  t[16] <- 8 ; t[17] <- 1; t[18] <- 9;
  tri_insertion_v0 t ; 
  t

end



module TriEx3 (* EXERCICE 3 *)
  use int.Int
  use ref.Ref
  use ref.Refint
  use array.Array
  use array.IntArraySorted
  use array.ArraySwap
  use array.ArrayPermut
  use array.ArrayEq
  
val tri_bulles (t: array int) : unit
 (* a modifier et completer  *) 


end  

